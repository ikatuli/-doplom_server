package squid

import(
	"os"
	"os/exec"
	"fmt"
)

func CreateConfig(conf map[string]string) error {
	f, err := os.Create("./configuration/squid.conf") 

	if err != nil {
		return err
	}
	defer f.Close()

	f.WriteString("# Generated by doplom server\n")

	f.WriteString(`
# Разрешаем базовые сети
acl localnet src 0.0.0.1-0.255.255.255	# RFC 1122 "this" network (LAN)
acl localnet src 10.0.0.0/8		# RFC 1918 local private network (LAN)
acl localnet src 100.64.0.0/10		# RFC 6598 shared address space (CGN)
acl localnet src 169.254.0.0/16 	# RFC 3927 link-local (directly plugged) machines
acl localnet src 172.16.0.0/12		# RFC 1918 local private network (LAN)
acl localnet src 192.168.0.0/16		# RFC 1918 local private network (LAN)
acl localnet src fc00::/7       	# RFC 4193 local private network range
acl localnet src fe80::/10      	# RFC 4291 link-local (directly plugged) machines	

# Безопасные порты
acl SSL_ports port 443
acl Safe_ports port 80      # http
acl Safe_ports port 21      # ftp
acl Safe_ports port 443     # https
acl Safe_ports port 70      # gopher
acl Safe_ports port 210     # wais
acl Safe_ports port 1025-65535  # unregistered ports
acl Safe_ports port 280     # http-mgmt
acl Safe_ports port 488     # gss-http
acl Safe_ports port 591     # filemaker
acl Safe_ports port 777     # multiling http

# Запрет небезопасных портов
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports

# Запрет возможности подключения к cachemgr не с локального комьютера.
http_access allow localhost manager
http_access deny manager

#Файл со списком заблокированных доменов
acl deniedsites dstdomain "/etc/squid/deniedsites.squid"
http_access deny deniedsites

#Файл с фильтрацией по ключевым словам
#acl keywords url_regex -i "/etc/squid/keywords.squid"
#http_access deny keywords

# Разрешаем доступ из локальной сети и локолхоста
http_access allow localnet
http_access allow localhost

#Запретить всем остальным
http_access deny all

#Порт прокси
`) 
	if conf["SSL"] !="" {
		fmt.Fprintln(f,"http_port ",conf["Port"]," ssl-bump tls-cert=/etc/squid/myCA.pem generate-host-certificates=on dynamic_cert_mem_cache_size=4MB options=NO_SSLv3,NO_TLSv1,NO_TLSv1_1,SINGLE_DH_USE,SINGLE_ECDH_USE")
		f.WriteString("ssl_bump stare all\nssl_bump bump all\n")

		err = exec.Command("/usr/lib/squid/security_file_certgen", "-c", "-s", "/var/cache/squid/ssl_db", "-M", "4MB").Run()
		if err != nil {
			fmt.Println(err)
		}

		} else {
			fmt.Fprintln(f,"http_port ",conf["Port"])
		}

	if conf["DNS"] !="" {
		f.WriteString(`
dns_nameservers 127.0.0.1
		`)
	}

	fmt.Fprintln(f,"#Директория для кеша")
	fmt.Fprintln(f,"cache_dir ufs /var/cache/squid ",conf["Cache"],"16 256")
	fmt.Fprintln(f,"#Максимальный размер кешируемого объекта")
	fmt.Fprintln(f,"maximum_object_size",conf["MaximumObjectSize"],"MB")

	

	f.WriteString(`
# Leave coredumps in the first cache dir
coredump_dir /var/cache/squid

# Правила жизни кеша
refresh_pattern ^ftp:       1440    20% 10080
refresh_pattern ^gopher:    1440    0%  1440
refresh_pattern -i (/cgi-bin/|\?) 0 0%  0
refresh_pattern .       0   20% 4320
`)

	if conf["e2guardian"] !="" {
		f.WriteString(`
# Подключение e2guardian
icap_enable on
icap_service service_req reqmod_precache bypass=0 icap://127.0.0.1:1344/request
icap_service service_resp respmod_precache bypass=0 icap://127.0.0.1:1344/response
adaptation_access service_req allow all
adaptation_access service_resp allow all
icap_send_client_ip on
icap_send_client_username on
adaptation_masterx_shared_names X-ICAP-E2G
`)
	}
    //Почему внешная команда, а н os.Rename?
	//Потому что /etc/ может находится в другой файловой системе, чем среда исполнения.
	err = exec.Command("mv","./configuration/squid.conf", "/etc/squid/squid.conf").Run()
    if err != nil {
        return err
    }

	//Перезагружаем прокси сервер 
	err = Start("restart") 
	if err != nil {
        return err
    }

	return err
	
//http://localhost:3128/squid-internal-mgr/info
}

func CreateCertificate() error {
	cmd := exec.Command("openssl", "req", "-new", "-subj", "/C=RU/ST=Some-State/O=Doplom Server", "-newkey", "rsa:2048", "-sha256","-days","3650", "-nodes", "-x509", "-extensions", "v3_ca", "-keyout", "./configuration/myCA.pem" ,"-out", "./configuration/myCA.pem")
	err:= cmd.Run()
	if err != nil {
        return err
    }

	cmd = exec.Command("openssl", "x509", "-in", "./configuration/myCA.pem", "-outform", "DER", "-out", "./configuration/myCA.der")
	err= cmd.Run()
	if err != nil {
        return err
    }

	cmd = exec.Command("openssl", "x509", "-in", "./configuration/myCA.pem", "-outform", "DER", "-out", "./configuration/myCA.der")
	err= cmd.Run()
	if err != nil {
        return err
    }

	err = exec.Command("mv","./configuration/myCA.pem", "/etc/squid/myCA.pem").Run()
    if err != nil {
        return(err)
    }

	return err
}

func Status () string {
	cmd:=exec.Command("systemctl","is-active","squid.service")
	stdout, _ := cmd.Output()
	tmp:=string(stdout)
	return tmp[0:len(tmp)-1]
}

func DeliteCache () error {
	var err error
	err = exec.Command("rm","-rf", "/var/cache/squid/[0-9]*").Run()
	if err != nil {
        return err
	}
	err = exec.Command("rm","-f", "/squid/cache/swap*").Run()
	if err != nil {
        return err
    }
	err = exec.Command("rm","-f", "/squid/cache/netdb*").Run()
	if err != nil {
        return err
    }

	err = exec.Command("rm","-f", "/squid/cache/*.log").Run()
	if err != nil {
        return err
    }

	return err
}


func Journal () string {
	cmd:=exec.Command("journalctl","-b","-u","squid.service")
	stdout, _ := cmd.Output()
	return string(stdout)
}

func Start (action string) error {
	cmd:=exec.Command("systemctl",action,"squid.service")
	err := cmd.Run()
	return err
}
